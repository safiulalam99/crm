
create table public.buyers (
  id serial,
  name text not null,
  address text not null,
  country text not null,
  vatnumber character varying(50) null,
  contractnumber character varying(50) null,
  contactperson text null,
  paymentterm text null,
  deliveryterm text null,
  registrationnumber character varying(50) null,
  currency_id integer null,
  contactpersonrole text null default ''::text,
  user_id uuid null,
  constraint buyers_pkey primary key (id),
  constraint buyers_currency_id_fkey foreign key (currency_id) references currencies (id) on update cascade,
  constraint buyers_user_id_fkey foreign key (user_id) references "user" (id) on update cascade on delete cascade
) tablespace pg_default;

create table public.sellers (
  id bigint primary key generated always as identity,
  name text not null,
  address text not null,
  vatnumber character varying(50) null,
  displayname text null,
  managingdirector text null,
  country text null,
  user_id uuid null,
  primary_address bigint null,
  constraint sellers_user_id_fkey foreign key (user_id) references "user" (id) on update cascade on delete
  set default,
    constraint sellers_primary_address_fkey foreign key (primary_address) references seller_addresses (id) on update cascade on delete
  set default
) tablespace pg_default;


create table
  public.invoices (
    invoicenumber text not null,
    vattype character varying(50) null,
    date date not null,
    deliveryterm text null,
    deliverydate date null,
    paymentsplit text null,
    subtotal numeric(10, 2) null,
    total numeric(10, 2) null,
    taxrate numeric(5, 2) null,
    totaltax numeric(10, 2) null,
    totaldiscount numeric(10, 2) null,
    discountrate numeric(5, 2) null,
    numberinwords text null,
    comments text null,
    paymentstatus character varying(50) null,
    buyer_id integer null,
    seller_id integer null,
    currency_id integer null default 1,
    time_stamp timestamp with time zone null default (now() at time zone 'utc'::text),
    user_id uuid null,
    bank_details_id integer null,
    id uuid not null default gen_random_uuid (),
    address_id bigint null,
    invoice_id bigint generated by default as identity,
    constraint invoice_pkey primary key (invoicenumber),
    constraint invoices_invoice_id_key unique (invoice_id),
    constraint invoices_id_key unique (id),
    constraint invoices_buyer_id_fkey foreign key (buyer_id) references buyers (id),
    constraint invoices_currency_id_fkey foreign key (currency_id) references currencies (id),
    constraint invoices_seller_id_fkey foreign key (seller_id) references sellers (id),
    constraint invoices_user_id_fkey foreign key (user_id) references "user" (id) on update cascade on delete cascade,
    constraint invoices_address_id_fkey foreign key (address_id) references seller_addresses (id),
    constraint invoices_bank_details_id_fkey foreign key (bank_details_id) references bank_details (id)
  ) tablespace pg_default;

create table public.currencies (
  id bigint primary key generated always as identity,
  name text not null,
  symbol text not null
) tablespace pg_default;


create table
  public.invoices_products (
    id serial,
    invoicenumber text null,
    product_id integer null,
    units integer not null,
    unitprice numeric(10, 2) not null,
    unitvat numeric(5, 2) not null,
    unittotal numeric(10, 2) not null,
    productlot text null default ''::text,
    languageversion text null default ''::text,
    user_id uuid null,
    invoices_id text null,
    constraint invoice_product_pkey primary key (id),
    constraint invoices_products_invoices_id_key unique (invoices_id),
    constraint invoices_products_invoicenumber_fkey foreign key (invoicenumber) references invoices (invoicenumber),
    constraint invoices_products_product_id_fkey foreign key (product_id) references products (id),
    constraint invoices_products_user_id_fkey foreign key (user_id) references "user" (id) on update cascade
  ) tablespace pg_default;


create table
  public.order_confirmation (
    invoicenumber text not null,
    vattype character varying(50) null,
    date date not null,
    deliveryterm text null,
    deliverydate date null,
    paymentsplit text null,
    subtotal numeric(10, 2) null,
    total numeric(10, 2) null,
    taxrate numeric(5, 2) null,
    totaltax numeric(10, 2) null,
    totaldiscount numeric(10, 2) null,
    discountrate numeric(5, 2) null,
    numberinwords text null,
    comments text null,
    paymentstatus character varying(50) null,
    buyer_id integer null,
    seller_id integer null,
    currency_id integer null default 1,
    time_stamp timestamp with time zone null default (now() at time zone 'utc'::text),
    user_id uuid null,
    address_id bigint null,
    id uuid not null default gen_random_uuid (),
    constraint invoices_pkey primary key (invoicenumber),
    constraint order_confirmation_id_key unique (id),
    constraint order_confirmation_buyer_id_fkey foreign key (buyer_id) references buyers (id),
    constraint order_confirmation_seller_id_fkey foreign key (seller_id) references sellers (id),
    constraint order_confirmation_user_id_fkey foreign key (user_id) references "user" (id) on update cascade on delete cascade,
    constraint order_confirmation_currency_id_fkey foreign key (currency_id) references currencies (id),
    constraint order_confirmation_address_id_fkey foreign key (address_id) references seller_addresses (id)
  ) tablespace pg_default;

create table
  public.order_confirmation_products (
    id serial,
    invoicenumber text null,
    product_id integer null,
    units integer not null,
    unitprice numeric(10, 2) not null,
    unitvat numeric(5, 2) not null,
    unittotal numeric(10, 2) not null,
    productlot text null default ''::text,
    languageversion text null default ''::text,
    user_id uuid null,
    constraint invoice_product_pkey primary key (id),
    constraint order_confirmation_products_invoicenumber_fkey foreign key (invoicenumber) references order_confirmation (invoicenumber),
    constraint order_confirmation_products_product_id_fkey foreign key (product_id) references products (id),
    constraint order_confirmation_products_user_id_fkey foreign key (user_id) references "user" (id) on update cascade
  ) tablespace pg_default;

create table
  products (
    id bigint primary key generated always as identity,
    name text not null,
    description text null,
    category text null,
    price numeric(10, 2) not null,
    time_stamp timestamp with time zone null default (now() at time zone 'utc'),
    defaultquantity numeric null default '0'::numeric,
    maxquantity numeric null default '0'::numeric,
    imageurl text null,
    status text null default 'active'::text,
    user_id uuid null,
    color text null default '#000000'::text,
    constraint products_user_id_fkey foreign key (user_id) references "user" (id) on update cascade
  )

create table
  public.proforma (
    invoicenumber text not null,
    vattype character varying(50) null,
    date date not null,
    deliveryterm text null,
    deliverydate date null,
    paymentsplit text null,
    subtotal numeric(10, 2) null,
    total numeric(10, 2) null,
    taxrate numeric(5, 2) null,
    totaltax numeric(10, 2) null,
    totaldiscount numeric(10, 2) null,
    discountrate numeric(5, 2) null,
    numberinwords text null,
    comments text null,
    paymentstatus character varying(50) null,
    buyer_id integer null,
    seller_id integer null,
    currency_id integer null default 1,
    time_stamp timestamp with time zone null default (now() at time zone 'utc'::text),
    user_id uuid null,
    address_id bigint null,
    proforma_id uuid not null default gen_random_uuid (),
    bank_details_id integer null,
    constraint proforma_pkey primary key (proforma_id),
    constraint proforma_proforma_id_key unique (proforma_id),
    constraint proforma_buyer_id_fkey foreign key (buyer_id) references buyers (id),
    constraint proforma_currency_id_fkey foreign key (currency_id) references currencies (id),
    constraint proforma_seller_id_fkey foreign key (seller_id) references sellers (id),
    constraint proforma_address_id_fkey foreign key (address_id) references seller_addresses (id),
    constraint proforma_user_id_fkey foreign key (user_id) references "user" (id),
    constraint proforma_bank_details_id_fkey foreign key (bank_details_id) references bank_details (id)
  ) tablespace pg_default;


create table
  public.proforma_products (
    id integer not null default nextval('invoices_products_id_seq'::regclass),
    product_id integer null,
    units integer not null,
    unitprice numeric(10, 2) not null,
    unitvat numeric(5, 2) not null,
    unittotal numeric(10, 2) not null,
    productlot text null default ''::text,
    languageversion text null default ''::text,
    user_id uuid null,
    proforma_id uuid null,
    invoicenumber text null,
    constraint proforma_products_pkey primary key (id),
    constraint proforma_products_product_id_fkey foreign key (product_id) references products (id),
    constraint proforma_products_proforma_id_fkey foreign key (proforma_id) references proforma (proforma_id),
    constraint proforma_products_user_id_fkey foreign key (user_id) references "user" (id)
  ) tablespace pg_default;

create table
  public.seller_addresses (
    id bigint primary key generated always as identity,
    seller_id bigint not null,
    address text not null,
    country text null,
    user_id uuid null,
    constraint seller_addresses_pkey primary key (id),
    constraint seller_addresses_address_id_key unique (id),
    constraint seller_addresses_seller_id_fkey foreign key (seller_id) references sellers (id) on delete cascade,
    constraint seller_addresses_user_id_fkey foreign key (user_id) references "user" (id) on update cascade
  ) tablespace pg_default;

create table
  public.user (
    id uuid not null default gen_random_uuid (),
    created_at timestamp with time zone not null default now(),
    role text null default 'user'::text,
    constraint user_pkey primary key (id)
  ) tablespace pg_default;

create table
  public.products (
    id bigint primary key generated always as identity,
    name text not null,
    description text null,
    category text null,
    price numeric(10, 2) not null,
    time_stamp timestamp with time zone null default (now() at time zone 'utc'::text),
    defaultquantity numeric null default '0'::numeric,
    maxquantity numeric null default '0'::numeric,
    imageurl text null,
    status text null default 'active'::text,
    user_id uuid null,
    color text null default '#000000'::text,
    constraint products_user_id_fkey foreign key (user_id) references "user" (id) on update cascade
  ) tablespace pg_default;


create table
  public.bank_details (
    id bigint primary key generated always as identity,
    iban text not null,
    bank text not null,
    bic text not null,
    seller_id bigint null,
    user_id uuid null,
    accountname text null,
    constraint bank_details_seller_id_fkey foreign key (seller_id) references sellers (id),
    constraint bank_details_user_id_fkey foreign key (user_id) references "user" (id) on update cascade
  ) tablespace pg_default;


CREATE OR REPLACE FUNCTION get_buyer_dashboard(buyer_id_param integer, user_id_param uuid)
RETURNS TABLE (
    total_proforma_transactions integer,
    total_invoice_transactions integer,
    total_order_confirmation_transactions integer,
    total_amount_invoices numeric(10, 2),
    total_amount_proforma numeric(10, 2),
    total_amount_order_confirmation numeric(10, 2),
    buyer_name text,
    buyer_country text,
    buyer_vatnumber varchar,
    buyer_contractnumber varchar,
    buyer_address text,
    buyer_contact_details text,
    buyer_contactperson text,
    buyerid integer,
    currency_details jsonb,
    associated_invoices text[],
    associated_order_confirmations text[],
    associated_proformas uuid[]
) AS $$
BEGIN
    -- Check if buyer exists
    IF NOT EXISTS (SELECT 1 FROM buyers WHERE id = buyer_id_param) THEN
        RAISE EXCEPTION 'No buyer found with ID %.', buyer_id_param;
    END IF;

    -- Check if user ID is associated with the buyer
    IF NOT EXISTS (SELECT 1 FROM buyers WHERE id = buyer_id_param AND user_id = user_id_param) THEN
        RAISE EXCEPTION 'Buyer with ID % is not associated with User ID %.', buyer_id_param, user_id_param;
    END IF;

    RETURN QUERY 
    SELECT
        CAST((SELECT COUNT(*) FROM proforma WHERE buyer_id = buyer_id_param) AS integer),
        CAST((SELECT COUNT(*) FROM invoices WHERE buyer_id = buyer_id_param) AS integer),
        CAST((SELECT COUNT(*) FROM order_confirmation WHERE buyer_id = buyer_id_param) AS integer),
        (SELECT COALESCE(SUM(total), 0) FROM invoices WHERE buyer_id = buyer_id_param),
        (SELECT COALESCE(SUM(total), 0) FROM proforma WHERE buyer_id = buyer_id_param),
        (SELECT COALESCE(SUM(total), 0) FROM order_confirmation WHERE buyer_id = buyer_id_param),
        b.name,
        b.country,  
        b.vatnumber,
        b.contractnumber,
        b.address,
        b.contactpersonrole,
        b.contactperson,
        b.id,
        (SELECT jsonb_agg(jsonb_build_object(
            'invoicenumber', i.invoicenumber,
            'buyer_id', i.buyer_id,
            'time_stamp', i.time_stamp,
            'currency', jsonb_build_object(
                'id', c.id,
                'name', c.name
                'symbol', c.symbol
            )
        )) FROM invoices i
        JOIN currencies c ON i.currency_id = c.id
        WHERE i.buyer_id = buyer_id_param),
        ARRAY(SELECT invoicenumber FROM invoices WHERE buyer_id = buyer_id_param),
        ARRAY(SELECT invoicenumber FROM order_confirmation WHERE buyer_id = buyer_id_param),
        ARRAY(SELECT proforma_id FROM proforma WHERE buyer_id = buyer_id_param)
    FROM buyers b
    WHERE b.id = buyer_id_param AND b.user_id = user_id_param;

EXCEPTION
    WHEN NO_DATA_FOUND THEN
        RAISE EXCEPTION 'No data found for the given parameters.';
    WHEN OTHERS THEN
        RAISE EXCEPTION 'An unexpected error occurred: %', SQLERRM;
END;
$$ LANGUAGE plpgsql;

-- get multiple order confiramtions from order confirmation table using invoicenumber and buyer_id
CREATE OR REPLACE FUNCTION get_associated_order_confirmations(buyer_id_param integer, order_confirmation_numbers text[])
RETURNS SETOF order_confirmation AS $$
DECLARE
    result RECORD;
BEGIN
    FOR result IN 
        SELECT * FROM order_confirmation
        WHERE invoicenumber = ANY(order_confirmation_numbers) AND buyer_id = buyer_id_param
    LOOP
        RETURN NEXT result;
    END LOOP;

    IF NOT FOUND THEN
        RAISE NOTICE 'No order confirmations found for the given criteria.';
    END IF;
END;
$$ LANGUAGE plpgsql;
SELECT * FROM get_associated_order_confirmations(21, ARRAY['kj']);


-- ************************************************************************
-- get multiple invoices from invoice table using proforma_id and buyer_id
-- ************************************************************************

DROP FUNCTION get_invoices_with_buyer_and_currency_details(text[],integer) ;
CREATE OR REPLACE FUNCTION get_invoices_with_buyer_and_currency_details(invoice_numbers text[], buyer_id_param integer)
RETURNS TABLE (
    -- Columns from invoices table
    invoice_id uuid,
    invoicenumber text,
    invoice_date date,
    invoice_timestamp timestamptz,
    total numeric(10, 2),
    -- Columns from buyers table
    buyer_name text,
    buyer_address text,
    -- Columns from currencies table
    currency_name varchar,
    currency_symbol varchar
) AS $$
BEGIN
    -- Check if the invoice_numbers array is empty
    IF array_length(invoice_numbers, 1) IS NULL THEN
        RAISE NOTICE 'Empty array provided for invoice_numbers.';
        RETURN;
    END IF;

    -- Directly return the query result with joins to buyers and currencies tables
    RETURN QUERY 
    SELECT
        i.id,
        i.invoicenumber,
        i.date,
        i.time_stamp,
        i.total,
        b.name AS buyer_name,
        b.address AS buyer_address,
        c.name AS currency_name,
        c.symbol AS currency_symbol
    FROM invoices i
    INNER JOIN buyers b ON i.buyer_id = b.id
    INNER JOIN currencies c ON i.currency_id = c.id
    WHERE i.invoicenumber = ANY(invoice_numbers) AND i.buyer_id = buyer_id_param;

    -- Check if any records were found and return an exception if not
    IF NOT FOUND THEN
        RAISE EXCEPTION 'No invoices found for the given criteria.';
    END IF;
END;
$$ LANGUAGE plpgsql;


-- ************************************************************************
-- get multiple order_confirmation from order_confirmation table using invoicenumber and buyer_id
-- ************************************************************************
CREATE OR REPLACE FUNCTION get_multiple_order_confirmations_with_currencies(order_confirmation_numbers text[], buyer_id_param integer)
RETURNS TABLE (
    -- Columns from order_confirmation table
    invoice_id uuid,
    invoicenumber text,
    invoice_date date,
    invoice_timestamp timestamptz,
    total numeric(10, 2),
    -- Columns from buyers table
    buyer_id integer,
    buyer_name text,
    buyer_address text,
    -- Columns from currencies table
    currency_name varchar,
    currency_symbol varchar
) AS $$
BEGIN
    -- Check if the order_confirmation_numbers array is empty
    IF array_length(order_confirmation_numbers, 1) IS NULL THEN
        RAISE NOTICE 'Empty array provided for order_confirmation_numbers.';
        RETURN;
    END IF;

    -- Directly return the query result with joins to buyers and currencies tables
    RETURN QUERY 
    SELECT
        oc.id,
        oc.invoicenumber,
        oc.date,
        oc.time_stamp,
        oc.total,
        b.id AS buyer_id,
        b.name AS buyer_name,
        b.address AS buyer_address,
        c.name AS currency_name,
        c.symbol AS currency_symbol
    FROM order_confirmation oc
    INNER JOIN buyers b ON oc.buyer_id = b.id
    INNER JOIN currencies c ON oc.currency_id = c.id
    WHERE oc.invoicenumber = ANY(order_confirmation_numbers) AND oc.buyer_id = buyer_id_param;

    -- No need for a loop or additional notice here as RETURN QUERY handles it
END;
$$ LANGUAGE plpgsql;


-- ************************************************************************
-- get multiple proforma from proforma table using proforma_id and buyer_id
-- ************************************************************************
